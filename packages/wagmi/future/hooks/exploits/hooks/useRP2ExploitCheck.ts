import { ZERO } from '@sushiswap/math'
import { useQuery } from '@tanstack/react-query'
import { isRouteProcessorChainId, routeProcessorAddress } from '@sushiswap/route-processor/exports/exports'
import { queryFnUseBalances } from '../../balances'
import { fetchTokensQueryFn, hydrateFetchTokensQueryFn } from '@sushiswap/react-query'
import { Address, erc20ABI, readContracts } from 'wagmi'
import { Token } from '@sushiswap/currency'
import { routeProcessor2ChainIds } from '@sushiswap/route-processor'

interface UseRP2ExploitCheck {
  account: Address | undefined
}

export const useRP2ExploitCheck = ({ account }: UseRP2ExploitCheck) => {
  return useQuery({
    queryKey: ['useRP2ExploitCheck', { account }],
    enabled: Boolean(account),
    queryFn: async () => {
      const tokens = await fetchTokensQueryFn()
      const vulnTokens = await Promise.all(
        routeProcessor2ChainIds.map(async (chainId) => {
          if (isRouteProcessorChainId(chainId)) {
            const currencies = await hydrateFetchTokensQueryFn(tokens, chainId)
            const balances = await queryFnUseBalances({
              chainId,
              account,
              currencies: Object.values(currencies),
            })

            if (balances) {
              const tokensWithBalance = Object.values(balances)
                .filter((el) => el.greaterThan(ZERO))
                .map((el) => el.currency.wrapped)

              const allowance = await readContracts({
                contracts: tokensWithBalance.map(
                  (el) =>
                    ({
                      chainId: chainId,
                      address: el.wrapped.address as Address,
                      abi: erc20ABI,
                      functionName: 'allowance',
                      args: [account as Address, routeProcessorAddress[chainId] as Address],
                    } as const)
                ),
              })

              return tokensWithBalance.reduce<Token[]>((acc, el, i) => {
                if (allowance[i].gt('0')) {
                  acc.push(el)
                }

                return acc
              }, [])
            }
          }

          return []
        })
      )

      return vulnTokens.flat()
    },
    // Every hour
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
    refetchIntervalInBackground: false,
    refetchInterval: 1000 * 60 * 60,
  })
}
